[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science Technologies",
    "section": "",
    "text": "Welcome\nTo ‘Data Science Technologies: A Non-Technical Guide’",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#book-outline",
    "href": "index.html#book-outline",
    "title": "Data Science Technologies",
    "section": "Book outline",
    "text": "Book outline\n\nIntroduction\nThe Data Science Ecosystem\nImportance and Relevance: The rising importance of data science and why having mental models of these technologies matters.\nEveryday Impact: How these technologies influence our everyday lives (social media, business, healthcare).\n\n\nPart I\nFoundational Concepts in Computational Statistics\n1.1. Code\nOverview of common programming languages and how they’re used to communicate with machines and humans.\n1.2. Data\nOverview of data types, data sources, and how data is collected.\n1.3. Command Line Interface\nIntroduction to CLI basics and its importance in data science.\n1.4. The Data Science Workflow\nSimplified explanation of the data science lifecycle from data collection to decision-making.\n\n\nPart II\nData Storage and Retrieval\n2.1. Data Processing\nCommon tasks for cleaning and transforming raw data.\n2.2 Big Data\nWorking with larger datasets using tools like Apache Hadoop, Spark, and SQL-based commands.\n3.3 Data Storage\nOverview of file formats (CSV, JSON, Parquet) and database tools (SQL, NoSQL, and data lakes).\n\n\nPart III\nComputational Analysis Tools\n3.1. Exploratory Data Analysis\nLeveraging visualization libraries (Matplotlib, Seaborn, ggplot2).\n3.2. Statistical Analysis with Python and R\nHow to conduct descriptive and inferential analysis\n3.3. Machine Learning Libraries\nOverview of key machine learning tools (Scikit-learn, TensorFlow, Keras, caret).\n\n\nPart IV\nMachine Learning in Practice\n4.1. Supervised Learning Algorithms\nRegression, classification, and decision trees using popular libraries.\n4.2. Unsupervised Learning Algorithms\nClustering, dimensionality reduction, and topic modeling techniques\n4.3. Model Evaluation and Optimization\nApproaches for model selection, tuning, and validation.\n\n\nPart V\nWeb Technologies\n\n\nPart VI\nAutomation and Pipelines\n6.1. Scripting and Automation\nBasics of writing data workflows with Python, Bash, and command-line tools\n6.2. Pipeline Orchestration Tools\nAirflow, Luigi, and others for managing data pipelines.\n6.3. Deployment Strategies\nCreating automated deployment workflows using Docker, Kubernetes, and serverless architectures.\n\n\nPart VII\nPutting It All Together\n7.1. Project Templates\nStep-by-step guide to designing and developing data science projects.\n7.2. Case Studies and Examples\nReal-world use cases demonstrating command-based data workflows.\n7.3. Beyond the Book\nResources for exploring data science tools further (open-source projects, courses, blogs).\n\n\nConclusion\nThe Future of Command-Based Data Science\nEmerging Trends: What’s next in command-based data science and how it connects with the broader tech landscape.\nPractical Skills Roadmap: How readers can continue building relevant skills and apply them to their own work.\n\n\nAppendix\nA1. Glossary of Key Terms\nA2. Supplementary References for Deep-Dive Learning",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "Who should read this book?\nThis book assumes the audience has no prior programming or computer experience, aside from using a keyboard and mouse to open files and folders. It’s especially suitable for anyone lacking confidence in their computer literacy.\nIt’s contents should serve as a quick start on unfamiliar topics, even for experienced data scientists, software engineers, etc., as long as the reader is not offended by overly simplified explanations of familiar material.\nI’ve found having general knowledge of the topics in this book has made it easier to talk to experts and understand key issues, so I also hope it will be helpful for a wider audience.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction",
    "section": "",
    "text": "Open source\nI’ve left the boilerplate text above in this text because it’s fitting for a book on data technology. Donald Knuth and his contributions to literate programming eventually lead to the document you’re reading. In literate programming, explanations and logic (written in natural language) are interspersed with snippets or ‘chunks’ of code, which can be compiled into various output formats, or used as a virtual notebook environment.\nIt’s hard to overstate the importance of this technology. Before literate programming, the world of code was largely separated from most other forms of written language. The combination of code with natural language…\nLiterate programming has done for code what…\nI’ve included the steps for publishing this book inside the book because it’s serves as an excellent example of the topics contained in this text. This book is written in Quarto, which is an ‘open-source scientific and technical publishing system.’ All of the tools in this text are open-source, which means the source code (i.e. files) to create it are ‘made freely available for possible modification and redistribution.’\nIf we look at the code files used to create this book in the folder tree below we notice multiple file types (extensions) and names:\n_book\n├── Data-Technologies.pdf\n├── code.html\n├── command-line.html\n├── files.html\n├── fun-arguments.html\n├── fun-environments.html\n├── fun-names.html\n├── fun-structure.html\n├── index.html\n├── intro.html\n├── notebooks.html\n├── oop-basics.html\n├── oop-in-python.html\n├── oop-in-r.html\n├── preface.html\n├── regex.html\n├── search.json\n└── site_libs\n    ├── bootstrap\n    │   ├── bootstrap-icons.css\n    │   ├── bootstrap-icons.woff\n    │   ├── bootstrap.min.css\n    │   └── bootstrap.min.js\n    ├── clipboard\n    │   └── clipboard.min.js\n    ├── quarto-html\n    │   ├── anchor.min.js\n    │   ├── popper.min.js\n    │   ├── quarto-syntax-highlighting.css\n    │   ├── quarto.js\n    │   ├── tippy.css\n    │   └── tippy.umd.min.js\n    ├── quarto-nav\n    │   ├── headroom.min.js\n    │   └── quarto-nav.js\n    └── quarto-search\n        ├── autocomplete.umd.js\n        ├── fuse.min.js\n        └── quarto-search.js\nEach of these\nThese files are stored in a GitHub repository. GitHub is a platform for hosting open source projects that use Git, the world’s most popular distributed version control system.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#collaboration",
    "href": "intro.html#collaboration",
    "title": "Introduction",
    "section": "Collaboration",
    "text": "Collaboration\nBasic knowledge of Git has become somewhat necessary when you decide to enter the data technology ecosystem (or other open-source projects). I won’t be diving into the Git workflow here, but I will cover the commands I used to store and publish this book.\nThe following commands are entered at the command line (Terminal if you’re using macOS).\n\nI created a repository on GitHub.com like this one: mjfrigaard/data-tech\nAdd (-A) and commit (commit -m) the files in the book folder:\n\n$ git add -A\n$ git commit -m \"first commit\"\n\npush local files to GitHub repo\n\n$ git remote add origin git@github.com:mjfrigaard/data-tech.git\n$ git branch -M main\n$ git push -u origin main\n\nCreate (checkout) an empty gh-pages branch\n\n$ git checkout --orphan gh-pages\nSwitched to a new branch 'gh-pages'\n$ git reset --hard \n$ git commit --allow-empty -m \"Initialising gh-pages branch\"\nInitialising gh-pages branch\n\npush the book files to the gh-pages branch\n\n$ git push origin gh-pages\nEnumerating objects: 2, done.\nCounting objects: 100% (2/2), done.\nWriting objects: 100% (2/2), 176 bytes | 176.00 KiB/s, done.\nTotal 2 (delta 0), reused 0 (delta 0), pack-reused 0\nremote: \nremote: Create a pull request for 'gh-pages' on GitHub by visiting:\nremote:      https://github.com/mjfrigaard/data-tech/pull/new/gh-pages\nremote: \nTo github.com:mjfrigaard/data-tech.git\n * [new branch]      gh-pages -&gt; gh-pages\n\nSwitch (checkout) back to main branch\n\n$ git checkout main\nSwitched to branch 'main'\nYour branch is up to date with 'origin/main'.\n\npublish to gh-pages branch\n\n$ quarto publish gh-pages\n? Update site at https://mjfrigaard.github.io/data-tech/? (Y/n) \n? Update site at https://mjfrigaard.github.io/data-tech/? (Y/n) Yes",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "01.1-code.html",
    "href": "01.1-code.html",
    "title": "Code",
    "section": "",
    "text": "Types of code\nLanguage is a technology that gives humans the ability to express ideas with precision. Natural languages like English or Spanish are used for a wide range of human communication, from slang terms in casual conversation to complex expressions of abstract ideas. Programming languages–what is typically meant when someone refers to ‘code’–are the arrangement of words, numbers, and/or symbols we use to communicate our intentions to a computer.\nNatural languages have a pragmatic quality that requires them to have high levels of redundancy. Redundancy helps us understand each other even when the rules of syntax are violated (i.e., when the same word can have different meanings in different contexts or when a sentence can have multiple valid interpretations).\nProgramming languages require higher levels of precision than natural languages. Poorly written sentences can be painful to read or difficult to comprehend, but they don’t ruin an entire book. Computers are uncompromising when it comes to syntax: code must perfectly conform to the rules for syntax, grammar, and semantics before the code will work. Writing code is like writing a book where a single typo makes the entire text illegible.\nCode can be broadly divided into two types: human and machine-readable.\nMachine-readable code consists of binary instructions (a series of 1s and 0s) that can be processed by computers directly. Machine code is fast and efficient to execute but is difficult for humans to read and write.\nAssembly languages are low-level languages that are a step above machine-readable code. These languages are somewhat human-readable but are still much more difficult for humans to read than high-level languages.\nLanguages like R, Python, JavaScript, and many others are high-level languages designed to be human-readable, with syntax and grammar that imitate natural languages. All higher-level code must be translated into machine-readable code before the computer can run it.",
    "crumbs": [
      "Part I",
      "Code"
    ]
  },
  {
    "objectID": "01.1-code.html#types-of-code",
    "href": "01.1-code.html#types-of-code",
    "title": "Code",
    "section": "",
    "text": "Markup languages\nA markup language is a human-readable text-encoding system used for describing the structure and format of web pages, documents, data, and configuration files.\n\n\n\n\n\n\nXML\n\n\n\nXML (eXtensible Markup Language) is a self-describing, flexible markup langauge that uses tags to define a document structure.\n&lt;tag&gt;content&lt;/tag&gt;\nTags are enclosed in angle brackets (&lt;/&gt;) and come in pairs to create elements. The first tag in the pair is the start tag (&lt;), and the second tag is the end tag, which is the same as the start tag, but also includes a forward slash (/&gt;).\nThe first line in XML documents are the referred to as the ‘declaration.’\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;note&gt;\n    &lt;to&gt;Bob&lt;/to&gt;\n    &lt;from&gt;Jane&lt;/from&gt;\n    &lt;heading&gt;Reminder&lt;/heading&gt;\n    &lt;body&gt;Don't forget to read your email!&lt;/body&gt;\n&lt;/note&gt;\nThe &lt;note&gt;/&lt;/note&gt; is the root element, and all other tags are child elements. The key advantage of XML is you can easily see what each piece of data represents.\n\n\nMarkup languages are not programming languages per se, but refer to a set of characters or symbols you can insert at certain places in a text file to indicate how the style of the output document should look when it’s printed or displayed.\nHTML (Hypertext Markup Language) provides the means to structure content on the web: structured documents to hold things like text, headings, paragraphs, lists, links, quotes, images, videos, etc.\n\n\n\n\n\n\nHTML\n\n\n\nHTML, or Hypertext Markup Language, is the standard language used to structure content on the web and is a fundamental technology used in all websites.\nHTML tags denote different types of content. The HTML document below begins with the &lt;!DOCTYPE html&gt; declaration and &lt;html&gt;/&lt;/html&gt; enclose the entire document.\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Title for page&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;This is a level 1 heading&lt;/h1&gt;\n    &lt;p&gt;This is the first paragraph.&lt;/p&gt;\n    &lt;p&gt;This is the second paragraph.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nInside &lt;html&gt;/&lt;/html&gt;, the &lt;head&gt;/&lt;/head&gt; elements contain information about the document’s browser’s title bar or tab (&lt;title&gt;/&lt;/title&gt;). The actual content of the webpage (headings (&lt;h1&gt;/&lt;/h1&gt;), paragraphs (&lt;p&gt;/&lt;/p&gt;) are wrapped in &lt;body&gt;/&lt;/body&gt;.\n\n\nMarkup languages annotate documents with a set of symbols that are syntactically distinguishable from its text. For example, Markdown is primarily used to convert plain text into HTML, but it’s also used to format README files, and for writing messages in online discussion forums like Stack Overflow.\n\n\n\n\n\n\nMarkdown\n\n\n\nMarkdown is a ‘lightweight’ markup language for creating formatted text using a text editor. For example, headers can be created using a number of # symbols corresponding to the header level (# Header 1 = level 1 header, ## Header 2 = level 2 header, etc.). Additional examples are below:\n\n\n\n\n\n\nMarkdown syntax\n*italic* or _italic_ for italic\n**bold** or __bold__ for bold \n***bold italic***\n\n\nRendered HTML\nitalic or italic for italic\nbold or bold for bold\nbold italic\n\n\n\n\n\n\n\n\n\n\nMarkdown syntax\n-   Item A   \n    *   Item A1      \n-   Item B      \n    *   Item B1  \n\n\nRendered HTML\n\nItem A\n\nItem A1\n\n\nItem B\n\nItem B1\n\n\n\n\n\n\n\n\n\n\n\n\nMarkdown syntax\n1. Item 1      \n2. Item 2      \n\n\nRendered HTML\n\nItem 1\n\nItem 2\n\n\n\n\n\n\n\n\nProgramming languages\n\n\n\n\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\n\nJavaScript\n\n\n\n\n\n\n\n\nOther languages\n\n\n\n\n\n\nYAML\n\n\n\nYAML is a human-friendly, easily readable data serialization standard that can be used in conjunction with all programming languages.",
    "crumbs": [
      "Part I",
      "Code"
    ]
  },
  {
    "objectID": "01.3-command-line.html",
    "href": "01.3-command-line.html",
    "title": "Command Line",
    "section": "",
    "text": "“In the beginning, there was the command line…” - essay by Neal Stephenson",
    "crumbs": [
      "Part I",
      "Command Line"
    ]
  }
]